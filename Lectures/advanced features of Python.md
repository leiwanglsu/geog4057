# Advanced features in Python

- Syntax errors
- Handling exceptions
- Debugging
- Lambda functions

## lambda and map functions

### lambda function

- A lambda function is a small anonymous function
- Some functions are only used once in your code. They then can be defined as a lambda function to make your code mort compact
- A lambda function can take any number of arguments, but can only have one expression
- Syntax: ```lambda arguments: expression```

Example:
This will add 10 to an argument and return the result

```python
x = lambda a: a + 10
print(x(5))
```

This will multiply a and b in the argument

```python
x = lambda a, b: a * b
print(x(5,6))
```

### Python map() function

- the map() function returns a map object of the result after applyging the given function to each item of the given iterable (tuple, list, ect)
- Syntax ```map(fun, iter)```
  
For example, this code will return a list of the result from the function `twice`

```python
def twice(n):
    return 2 * n
 
# We double all numbers using map()
numbers = (1, 2, 3, 4)
result = map(twice, numbers)
print(list(result))
```

```python
# Use the lambda function and map function
result = list(map(lambda x: x + x,numbers))
print(list(result))
```

## Work with syntax errors

### Common syntax errors

- Syntax errors are very common in writing script.
- Common syntax errors might be misspelled keywords or variables, missing punctuation, and in consistent indentation
- SyntaxError: invalid syntax is displayed when such error occur
- To avoid syntax errors, try to use an IDE that have built-in checking tools such as the intellisense in VS Code
- Try this code in the notebook and observe the error message

```python
import arcpy
arcpy.env.workspace = "C:/Data/mydata.gdb"
fclist = arcpy.ListFeatureClasses()
for fc in fclist
    count = arcpy.GetCount_management(fc)
    print(count)
```

### Locate the error by the line number

- In the notebook, you can toggle the line numbers
- Read the error message and figure out which line caused that error

### Exceptions

- Exceptions are errors detected while the script is running but not generated by syntax errors
- When an exception is detected, the script stops running and displays the exception information
- The action is called "throw an exception"
- If the exception is handled by the script, that is, it is "caught" - the program can continue running

## Debugging

- When the script has no synatx errors but still not runs, you need to find the "bugs" or debugging
- The following ways are commonly used methods to debug problems
  - Carefully reviewing the content of error messages
  - Adding print messages to your script
  - Selectively commenting out code
  - Using a Python debugger

### Carefully review the content of error messages

```python
import arcpy
arcpy.env.workspace = "C:/Data"
infcs = ["streams.shp", "floodzone.shp"]
outfc = "union.shp"
arcpy.Union_analysis(infcs, outfc)
```

- The above script will not run because the Union tool works with polygon features only
- An exception was thrown and the information was printed
- You can also use the Error code to find out the meaning of the error, for example ERROR 000366 is "Invalid geometry type"

### Adding print messages to your script

- Using print() function is always helpful when debugging for errors
- You can use print() to insert messages before and after a function that could generate problems. 

```python
import arcpy
arcpy.env.overwriteOutput = True
arcpy.env.workspace = "C:/Data"
arcpy.Buffer_analysis("roads.shp", "buffer.shp", "1000 METERS")
print("Buffer completed")
arcpy.Erase_analysis("buffer.shp", "zone.shp", "erase.shp")
print("Erase completed")
arcpy.Clip_analysis("erase.shp", "wetlands.shp", "clip.shp")
print("Clip completed")
```

- Print varaible values is another way to check the problems

```python
import arcpy
import os
arcpy.env.workspace = "C:/Transportation"
outgdb = "C:/Transportation/City.gdb"
fcs = arcpy.ListFeatureClasses()
for fc in fcs:
    desc = arcpy.da.Describe(fc)
    outfc = os.path.join(outgdb, desc["baseName"])
    print(outfc)
    ##arcpy.CopyFeatures_management(fc, outfc)
```

### Selectively commenting out code

- Selectively commenting out code involves removing certain lines to see if this eliminates the error.
- Use the hash mark # to add comments or remove comments

### Use Python debugger

- A more general approach is to use a Python debugger
- The package "pdb" is a built-in debugger package in python

```python
def example_function(x, y):
    result = x + y
    import pdb; pdb.set_trace()  # Start debugger here

    result *= 2
    print(result)
    return result

print('pdb debugging')
example_function(3, 4)
```

#### Cheating sheet for pdb

- n(ext) Step over
- s(tep) Step into
- r(eturn) Continue until the function returns
- c(continue) Continue until the next breakpoint is encountered
- a(rgs) Print arguments of the current function
- 

## Error handling for exceptions

- Although your code is error free, but exceptions still could occur, such as no internet connection, file locked by another process, no enough computer memory, etc.
- To write robust script that is resistent to those exceptional situations, you can use the error handling strategy in Python. 

### Using if statement

- you can write if-else blocks to check if certain situation happens, for example, if data does not exist

```python
import arcpy
arcpy.env.workspace = "C:/Data"
shape_exists = arcpy.Exists("streams.shp")
print(shape_exists)
```

- The Exist() function can be used for feature classes, tables, datasets, shapefiles, workspaces, ect.
- Even the data exist, there are other situations such as incorrect data type. The function expects a polygon but the input data is a point feature class
- Use da.Describe() to get the datasetType property and determine if the data type is correct

### Usin the try-except statement

- Although if statements work for most cases, the synatx is tedious, and it is impossible to check all kinds of errors
- Using the try-except statement can catch the exceptions and handle them before they are thrown

``` python
x = input("First integer: ")
y = input("Second integer: ")
print(int(x)/int(y))
```

- The above script is fine until you enter a 0 for y
- "ZeroDivisionError: division by zero"

- To handle the exception, you can add the try-except statement:

```python
try:
    x = input("First integer: ")
    y = input("Second integer: ")
    print(int(x)/int(y))
except ZeroDivisionError:
    print("The second integer cannot be zero.")
```

- note that ZeroDivisionError is a named exception
- You can catch mutliple named exceptions

```python
try:
    x = input("First integer: ")
    y = input("Second integer: ")
    print(int(x)/int(y))
except ZeroDivisionError:
    print("The second integer cannot be zero.")
except ValueError:
    print("Only integers are valid entries.")
```

- Or specify them as a tuple:
  
```python
except (ZeroDivisionError, ValueError):
    print("Your entries were not valid.")
```

- It can be difficult to predict all the types of named exceptons; therefore, it generally uses "Exception" without a specific exception name
- A commmon practice is to assign the exception to an variable and interact with it in the code:

```python
try:
    x = input("First integer: ")
    y = input("Second integer: ")
    print(int(x)/int(y))
except Exception as e:
    print(e)
```

### try-except-else-finally statement

- A more complete structure of the try statement is try - except - else - finally

```python
def division_example(dividend, divisor):
    try:
        result = dividend / divisor
    except ZeroDivisionError:
        print("Error: Division by zero is not allowed.")
    else:
        print("The division result is:", result)
    finally:
        print("Division operation completed.")

# Example usage:
dividend = 10
divisor = 2
division_example(dividend, divisor)

dividend = 10
divisor = 0
division_example(dividend, divisor)

```

- the else block is activated if no exception occurred
- the finally block is activated after all the statements were run and regardless if there were error or not.

### raise your own exceptions

- You can create customized named exceptions by deriving from the existing exception classes
- Read the following code:

```python
class TooShortError(ValueError):
    pass
try:
    password = input("Enter a new password: ")
    if len(password) > 5:
        print("Your password is long enough.")
    else:
        raise TooShortError
except TooShortError:
    print("Your password is too short.")
```

- The TooShortError is derived from the class ValueError 
- The statement raise throw the TooShortError exception
- The try except statement catches the exception and print the message specifically for the password to short problem.

### Handling geoprocessing exceptions

- When ArcPy encounters the problem generated by a geoprocessing tool, it throws an ExecuteError exception
- Use the arcpy.ExecuteError class to handle it:

```python
import arcpy
arcpy.env.workspace = "C:/Data"
in_features = "streams.shp"
out_features = "streams.shp"
try:
    arcpy.CopyFeatures_management(in_features, out_features)
except arcpy.ExecuteError:
    print(arcpy.GetMessages(2))
except:
    print("There has been a nontool error.")
```

- You can handle both named and unnamed exceptions in your script. But you need to catch named exceptions first.

### Using python traceback

- In larger scripts, it can be difficult to determine the precise location of an error.
- You can use the Python traceback module to isolate the location and cause of an error.

```python
import arcpy,sys,traceback
arcpy.env.workspace = "C:/Data"
in_features = "streams.shp"
out_features = "streams.shp"
try:
    arcpy.CopyFeatures_management(in_features, out_features)
except:
    tb = sys.exc_info()[2]
    tbinfo = traceback.format_tb(tb)[0]
    print("PYTHON ERRORS:\nTraceback info:\n")
    print(tbinfo)
    print(f"Error Info:\n {str(sys.exc_info() [1])}")
```

#### Understanding sys.exc_info()

- This function will return errors and exceptions that occur during execution of a script
- A tuple is returned by this function including three elements:
  - The type of error (the Exception Class)
  - The exception value (an object from the Exception class)
  - The traceback object
  - Use sys.exc_info()[2] to retrieve the traceback value

#### Understanding the traceback object

- The traceback class contains many functions to work with system execution errors
- Use traceback.print_exc() to print the information as traceback format
- Or use traceback.print_exeption(exc_type, exc_value, exc_tb) 

`traceback.print_exception(*sys.exc_info())` 

- Function format_exception will format the traceback info as a list of information

