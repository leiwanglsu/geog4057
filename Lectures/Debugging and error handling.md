## Work with syntax errors

### Common syntax errors

- Syntax errors are very common in writing script.
- Common syntax errors might be misspelled keywords or variables, missing punctuation, and in consistent indentation
- SyntaxError: invalid syntax is displayed when such error occur
- To avoid syntax errors, try to use an IDE that have built-in checking tools such as the intellisense in VS Code
- Try this code in the notebook and observe the error message

``` python
import arcpy
arcpy.env.workspace = "C:/Data/mydata.gdb"
fclist = arcpy.ListFeatureClasses()
for fc in fclist
    count = arcpy.GetCount_management(fc)
    print(count)
```
### Locate the error by the line number

- In the notebook, you can toggle the line numbers
- Read the error message and figure out which line caused that error


### Exceptions

- Exceptions are errors detected while the script is running but not generated by syntax errors
- When an exception is detected, the script stops running and displays the exception information
- The action is called "throw an exception"
- If the exception is handled by the script, that is, it is "caught" - the program can continue running

## Debugging

- When the script has no synatx errors but still not runs, you need to find the "bugs" or debugging
- The following ways are commonly used methods to debug problems
  - Carefully reviewing the content of error messages
  - Adding print messages to your script
  - Selectively commenting out code
  - Using a Python debugger

### Carefully review the content of error messages

```python
import arcpy
arcpy.env.workspace = "C:/Data"
infcs = ["streams.shp", "floodzone.shp"]
outfc = "union.shp"
arcpy.Union_analysis(infcs, outfc)
```

- The above script will not run because the Union tool works with polygon features only
- An exception was thrown and the information was printed
- You can also use the Error code to find out the meaning of the error, for example ERROR 000366 is "Invalid geometry type"

### Adding print messages to your script

- Using print() function is always helpful when debugging for errors
- You can use print() to insert messages before and after a function that could generate problems. 

```python
import arcpy
arcpy.env.overwriteOutput = True
arcpy.env.workspace = "C:/Data"
arcpy.Buffer_analysis("roads.shp", "buffer.shp", "1000 METERS")
print("Buffer completed")
arcpy.Erase_analysis("buffer.shp", "zone.shp", "erase.shp")
print("Erase completed")
arcpy.Clip_analysis("erase.shp", "wetlands.shp", "clip.shp")
print("Clip completed")
```

- Print varaible values is another way to check the problems

```python
import arcpy
import os
arcpy.env.workspace = "C:/Transportation"
outgdb = "C:/Transportation/City.gdb"
fcs = arcpy.ListFeatureClasses()
for fc in fcs:
    desc = arcpy.da.Describe(fc)
    outfc = os.path.join(outgdb, desc["baseName"])
    print(outfc)
    ##arcpy.CopyFeatures_management(fc, outfc)
```

### Selectively commenting out code

- Selectively commenting out code involves removing certain lines to see if this eliminates the error.
- Use the hash mark # to add comments or remove comments

### Use Python debugger

- A more general approach is to use a Python debugger
- The package "pdb" is a built-in debugger package in python


## Error handling for exceptions

- Although your code is error free, but exceptions still could occur, such as no internet connection, file locked by another process, no enough computer memory, etc.
- To write robust script that is resistent to those exceptional situations, you can use the error handling strategy in Python. 

### Using if statement

- you can write if-else blocks to check if certain situation happens, for example, if data does not exist

```python
import arcpy
arcpy.env.workspace = "C:/Data"
shape_exists = arcpy.Exists("streams.shp")
print(shape_exists)
```

- The Exist() function can be used for feature classes, tables, datasets, shapefiles, workspaces, ect.
- Even the data exist, there are other situations such as incorrect data type. The function expects a polygon but the input data is a point feature class
- Use da.Describe() to get the datasetType property and determine if the data type is correct


### Usin the try-except statement

- Although if statements work for most cases, the synatx is tedious, and it is impossible to check all kinds of errors
- Using the try-except statement can catch the exceptions and handle them before they are thrown

``` python
x = input("First integer: ")
y = input("Second integer: ")
print(int(x)/int(y))
```

- The above script is fine until you enter a 0 for y
- "ZeroDivisionError: division by zero"

- To handle the exception, you can add the try-except statement:

```python
try:
    x = input("First integer: ")
    y = input("Second integer: ")
    print(int(x)/int(y))
except ZeroDivisionError:
    print("The second integer cannot be zero.")
```

- note that ZeroDivisionError is a named exception
- You can catch mutliple named exceptions

```python
try:
    x = input("First integer: ")
    y = input("Second integer: ")
    print(int(x)/int(y))
except ZeroDivisionError:
    print("The second integer cannot be zero.")
except ValueError:
    print("Only integers are valid entries.")
```

- Or specify them as the tuple:
  
```
except (ZeroDivisionError, ValueError):
    print("Your entries were not valid.")
```

- It can be difficult to predict all the types of named exceptons; therefore, it generally uses "Exception" without a specific exception name
- A commmon practice is to assign the exception to an variable and interact with it in the code:

```python
try:
    x = input("First integer: ")
    y = input("Second integer: ")
    print(int(x)/int(y))
except Exception as e:
    print(e)
```

### try-except-else-finally statement

- A more complete structure of the try statement is try - except - else - finally

```python
def division_example(dividend, divisor):
    try:
        result = dividend / divisor
    except ZeroDivisionError:
        print("Error: Division by zero is not allowed.")
    else:
        print("The division result is:", result)
    finally:
        print("Division operation completed.")

# Example usage:
dividend = 10
divisor = 2
division_example(dividend, divisor)

dividend = 10
divisor = 0
division_example(dividend, divisor)

```
- the else block is activated if no exception occurred
- the finally block is activated after all the statements were run and regardless if there were error or not.

### raise your own exceptions

- You can create customized named exceptions by deriving from the existing exception classes
- Read the following code:

```python
class TooShortError(ValueError):
    pass
try:
    password = input("Enter a new password: ")
    if len(password) > 5:
        print("Your password is long enough.")
    else:
        raise TooShortError
except TooShortError:
    print("Your password is too short.")
```

- The TooShortError is derived from the class ValueError 
- The statement raise throw the TooShortError exception
- The try except statement catches the exception and print the message specifically for the password to short problem.

### Handling geoprocessing exceptions

- When ArcPy encounters the problem generated by a geoprocessing tool, it throws an ExecuteError exception
- Use the arcpy.ExecuteError class to handle it:

```python
import arcpy
arcpy.env.workspace = "C:/Data"
in_features = "streams.shp"
out_features = "streams.shp"
try:
    arcpy.CopyFeatures_management(in_features, out_features)
except arcpy.ExecuteError:
    print(arcpy.GetMessages(2))
except:
    print("There has been a nontool error.")
```

- You can handle both named and unnamed exceptions in your script. But you need to catch named exceptions first.


### Using python trackback

- In larger scripts, it can be difficult to determine the precise location of an error. You can use the Python traceback module to isolate the location and cause of an error.

```python
except:
    tb = sys.exc_info()[2]
    tbinfo = traceback.format_tb(tb)[0]
    pymsg = ("PYTHON ERRORS:\nTraceback info:\n" + tbinfo + 
             "\nError Info:\n" + str(sys.exc info() [1]))
```
